const e=new WeakMap;function editLedger(t,n,s,o){if(!t&&!e.has(n))return false;const a=e.get(n)??new WeakMap;e.set(n,a);const r=a.get(s)??new Set;a.set(s,r);const c=r.has(o);t?r.add(o):r.delete(o);return c&&t}function safeClosest(e,t){let n=e.target;n instanceof Text&&(n=n.parentElement);if(n instanceof Element&&e.currentTarget instanceof Element){const s=n.closest(t);if(s&&e.currentTarget.contains(s))return s}}function delegate(e,t,n,s={}){const{signal:o,base:a=document}=s;if(o?.aborted)return;const{once:r,...c}=s;const i=a instanceof Document?a.documentElement:a;const d=Boolean("object"===typeof s?s.capture:s);const listenerFn=s=>{const o=safeClosest(s,e);if(o){const e=Object.assign(s,{delegateTarget:o});n.call(i,e);if(r){i.removeEventListener(t,listenerFn,c);editLedger(false,i,n,l)}}};const l=JSON.stringify({selector:e,type:t,capture:d});const f=editLedger(true,i,n,l);f||i.addEventListener(t,listenerFn,c);o?.addEventListener("abort",(()=>{editLedger(false,i,n,l)}))}async function oneEvent(e,t,n={}){return new Promise((s=>{n.once=true;n.signal?.aborted&&s(void 0);n.signal?.addEventListener("abort",(()=>{s(void 0)}));delegate(e,t,s,n)}))}export{delegate as default,oneEvent};

